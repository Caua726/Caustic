use "std/mem.cst";
use "std/linux.cst";

fn main() as i32 {
    // Aloca 6 GB de heap para usar 5GB
    gheapinit(6442450944);
    write(STDOUT, "Heap de 6GB inicializado!\n", 26);
    write(STDOUT, "Alocando blocos grandes...\n", 27);
    
    // Aloca 500 blocos de 10MB cada = 5GB de RAM REAL
    let is i64 as num_blocks = 500;
    let is i64 as block_size = 10485760; // 10 MB
    
    // Array para guardar os ponteiros (precisa manter alocado!)
    let is **u8 as ptrs = cast(**u8, galloc(num_blocks * 8));
    
    // Aloca e ESCREVE em cada bloco (força commit de RAM física)
    let is i64 as i with mut = 0;
    while (i < num_blocks) {
        ptrs[i] = galloc(block_size);
        
        // Escreve em várias posições para forçar páginas físicas
        let is i64 as j with mut = 0;
        while (j < block_size) {
            ptrs[i][j] = cast(u8, 65 + (i - ((i / 26) * 26)));
            j = j + 4096; // Escreve a cada 4KB (tamanho de página)
        }
        
        i = i + 1;
    }
    
    write(STDOUT, "5GB de RAM alocado e escrito!\n", 31);
    write(STDOUT, "Mantendo alocado por 30s...\n", 28);
    
    // Mantém rodando por 30 segundos fazendo operações
    let is i64 as loops = 30000000; // ~30 segundos em CPU moderna
    let is i64 as k with mut = 0;
    while (k < loops) {
        // Lê aleatoriamente dos blocos para manter na RAM
        let is i64 as idx = k - ((k / num_blocks) * num_blocks);
        let is i64 as offset = k - ((k / 1000) * 1000);
        let is u8 as dummy = ptrs[idx][offset];
        
        k = k + 1;
    }
    
    write(STDOUT, "Liberando memoria...\n", 21);
    
    // Libera tudo
    i = 0;
    while (i < num_blocks) {
        gfree(ptrs[i]);
        i = i + 1;
    }
    gfree(cast(*u8, ptrs));
    
    write(STDOUT, "Teste completo! Heap OK!\n", 25);
    exit(0);
    return 0;
}