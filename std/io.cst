use "linux.cst" as linux;
use "string.cst" as string;
use "mem.cst" as mem;

struct File {
    fd as i64;
}

fn print(s as string.String) {
    if (s.len > 0) {
        linux.write(linux.STDOUT, s.ptr, cast(i64, s.len));
    }
}

fn println(s as string.String) {
    print(s);
    linux.write(linux.STDOUT, "\n", 1);
}

fn print_int(n as i64) {
    let is string.String as s = string.int_to_string(n);
    print(s);
    string.string_free(s);
}

fn read_line() as string.String {
    let is i64 as cap with mut = 128;
    let is i64 as len with mut = 0;
    let is *u8 as ptr with mut = mem.galloc(cap);

    while (1 == 1) {
        if (len + 1 >= cap) {
            let is i64 as new_cap = cap * 2;
            let is *u8 as new_ptr = mem.galloc(new_cap);
            mem.memcpy(new_ptr, ptr, len);
            mem.gfree(ptr);
            ptr = new_ptr;
            cap = new_cap;
        }

        let is i64 as addr = cast(i64, ptr) + len;
        let is i64 as n = linux.read(linux.STDIN, cast(*u8, addr), 1);

        if (n <= 0) {
            break;
        }

        if (ptr[len] == 10) { // \n
            break;
        }

        len = len + 1;
    }

    ptr[len] = 0; // Null terminator

    let is string.String as s;
    s.ptr = ptr;
    s.len = cast(i32, len);
    s.cap = cast(i32, cap);

    return s;
}

// Lê um arquivo inteiro para uma String (Slurp)
fn read_file(path as string.String) as string.String {
    // 1. Abre
    let is i64 as fd = linux.open(path.ptr, linux.O_RDONLY, 0);
    if (fd < 0) { 
        return string.String(""); // Retorna vazia em erro
    }

    // 2. Tamanho
    let is i64 as size = linux.lseek(fd, 0, linux.SEEK_END);
    linux.lseek(fd, 0, linux.SEEK_SET); // Rewind

    // 3. Aloca
    let is string.String as s;
    s.len = cast(i32, size);
    s.cap = cast(i32, size);
    
    if (size > 0) {
        s.ptr = cast(*u8, mem.galloc(size + 1));
        // 4. Lê
        linux.read(fd, s.ptr, size);
        s.ptr[size] = 0;
    } else {
        s.ptr = cast(*u8, 0);
    }

    // 5. Fecha
    linux.close(fd);

    return s;
}


// Escreve string em arquivo (Sobrescreve/Cria)
// Flags: O_WRONLY(1) | O_CREAT(64) | O_TRUNC(512) = 577
// Mode: 0644 = 420 (decimal)
fn write_file(path as string.String, content as string.String) as i64 {
    let is i64 as fd = linux.open(path.ptr, 577, 420);
    
    if (fd < 0) {
        return fd; // Erro
    }

    let is i64 as res = linux.write(fd, content.ptr, cast(i64, content.len));
    linux.close(fd);
    
    return res;
}

// Adiciona ao final do arquivo
// Flags: O_WRONLY(1) | O_CREAT(64) | O_APPEND(1024) = 1089
fn append_file(path as string.String, content as string.String) as i64 {
    let is i64 as fd = linux.open(path.ptr, 1089, 420);
    
    if (fd < 0) {
        return fd;
    }

    let is i64 as res = linux.write(fd, content.ptr, cast(i64, content.len));
    linux.close(fd);
    
    return res;
}

// Verifica se arquivo existe tentando abrir
fn file_exists(path as string.String) as i32 {
    // O_RDONLY = 0
    let is i64 as fd = linux.open(path.ptr, 0, 0);
    if (fd >= 0) {
        linux.close(fd);
        return 1; // True
    }
    return 0; // False
}

// Move o cursor do arquivo
// whence: 0 (SEEK_SET), 1 (SEEK_CUR), 2 (SEEK_END)
fn file_seek(f as File, offset as i64, whence as i64) as i64 {
    return linux.lseek(f.fd, offset, whence);
}

// Abre arquivo para streaming
fn open_file(path as string.String) as File {
    let is i64 as fd = linux.open(path.ptr, linux.O_RDONLY, 0);
    
    let is File as f;
    f.fd = fd;
    
    return f;
}

fn close_file(file as File) {
    linux.close(file.fd);
}