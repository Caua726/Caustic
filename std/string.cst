use "linux.cst";
use "mem.cst";

struct String {
    ptr as *u8;
    len as i32;
    cap as i32;   
}

fn strlen( s as *u8) as i64 {
    let is i64 with mut = 0;
    while (s[is] != 0) {
        is = is + 1;
    }
    return is;
}

fn getbeforevalue() as *String {
    let is *String as ctx;
    asm("mov rax, r10");
    return ctx;
}

fn String(text as *u8) as String {
    // 1. Quem vai receber esse valor?
    let is *String as target = get_context();
    let is i64 as l = strlen(text);
    let is i32 as new_len = cast(i32, l);
    let is String as s;

    // 2. É uma Atribuição? (Target != 0)
    if (cast(i64, target) != 0) {
        
        // OTIMIZAÇÃO: Reutilizar memória se couber
        // Se o alvo já tem um buffer válido E cabe o texto novo...
        if (cast(i64, target.ptr) != 0 && target.cap >= new_len) {
            // Copia para o buffer JÁ EXISTENTE do alvo
            memcpy(target.ptr, text, l);
            
            // Retorna uma struct configurada para MANTER esse ponteiro
            s.ptr = target.ptr;
            s.cap = target.cap; // Mantém a capacidade grande
            s.len = new_len;
            
            // O operador '=' vai sobrescrever a struct na stack, 
            // mas o ponteiro no heap foi preservado e reutilizado!
            return s;
        }

        // Se não cabe ou é inválido, TEMOS que limpar o antigo
        if (cast(i64, target.ptr) != 0) {
            gfree(target.ptr);
        }
    }

    // 3. Alocação Padrão (Declaração ou Atribuição que estourou capacidade)
    s.len = new_len;
    s.cap = new_len; // Aloca exato (Fit)
    
    if (l > 0) {
        s.ptr = cast(*u8, galloc(l));
        memcpy(s.ptr, text, l);
    } else {
        s.ptr = cast(*u8, 0);
    }
    
    return s;
}

// Função manual caso queira limpar antes de sair do escopo
fn string_free(s as String) {
    if (cast(i64, s.ptr) != 0) {
        gfree(s.ptr);
    }
}

fn string_print(s as String) {
    if (s.len > 0) {
        write(1, s.ptr, cast(i64, s.len));
        write(1, "\n", 1);
    }
}