use "linux.cst";
use "mem.cst";

struct String {
    ptr as *u8;
    len as i32;
    cap as i32;   
}

fn strlen( s as *u8) as i64 {
    let is i64 as i with mut = 0;
    while (s[i] != 0) {
        i = i + 1;
    }
    return i;
}

fn getbeforevalue() as *String {
    let is *String as ctx;
    asm("mov rax, r10");
    return cast(*String, ctx);
}

fn String(text as *u8) as String {
    // 1. Quem vai receber esse valor?
    let is *String as target = getbeforevalue();
    let is i64 as l = strlen(text);
    let is i32 as new_len = cast(i32, l);
    let is String as s;

    // 2. É uma Atribuição? (Target != 0)
    if (cast(i64, target) != 0) {
        
        // OTIMIZAÇÃO: Reutilizar memória se couber
        // Se o alvo já tem um buffer válido E cabe o texto novo...
        if (cast(i64, target.ptr) != 0 && target.cap >= new_len) {
            // Copia para o buffer JÁ EXISTENTE do alvo
            memcpy(target.ptr, text, l);
            
            // Retorna uma struct configurada para MANTER esse ponteiro
            s.ptr = target.ptr;
            s.cap = target.cap; // Mantém a capacidade grande
            s.len = new_len;
            
            // O operador '=' vai sobrescrever a struct na stack, 
            // mas o ponteiro no heap foi preservado e reutilizado!
            return s;
        }

        // Se não cabe ou é inválido, TEMOS que limpar o antigo
        if (cast(i64, target.ptr) != 0) {
            gfree(target.ptr);
        }
    }

    // 3. Alocação Padrão (Declaração ou Atribuição que estourou capacidade)
    s.len = new_len;
    s.cap = new_len; // Aloca exato (Fit)
    
    if (l > 0) {
        s.ptr = cast(*u8, galloc(l));
        memcpy(s.ptr, text, l);
    } else {
        s.ptr = cast(*u8, 0);
    }
    
    return s;
}

// Função manual caso queira limpar antes de sair do escopo
fn free(s as String) {
    if (cast(i64, s.ptr) != 0) {
        gfree(s.ptr);
    }
}

fn concat(s1 as String, s2 as String) as String {
    let is i64 as l1 = cast(i64, s1.len);
    let is i64 as l2 = cast(i64, s2.len);
    let is i64 as total_len = l1 + l2;
    
    let is String as new_s;
    new_s.len = cast(i32, total_len);
    new_s.cap = cast(i32, total_len);
    
    if (total_len > 0) {
        new_s.ptr = cast(*u8, galloc(total_len + 1));
        
        if (l1 > 0) {
            memcpy(new_s.ptr, s1.ptr, l1);
        }
        
        if (l2 > 0) {
            let is i64 as dest_addr = cast(i64, new_s.ptr) + l1;
            memcpy(cast(*u8, dest_addr), s2.ptr, l2);
        }
        
        // Null terminate
        let is i64 as end_addr = cast(i64, new_s.ptr) + total_len;
        let is *u8 as end_ptr = cast(*u8, end_addr);
        end_ptr[0] = 0; 
    } else {
        new_s.ptr = cast(*u8, 0);
    }
    
    return new_s;
}

fn int_string(n as i64) as String {
    let is i64 as temp with mut = n;
    let is i64 as len with mut = 0;
    let is i64 as is_neg with mut = 0;
    
    if (n == 0) {
        len = 1;
    } else {
        if (n < 0) {
            is_neg = 1;
            temp = 0 - n;
            len = len + 1;
        }
        
        let is i64 as counter with mut = temp;
        while (counter > 0) {
            counter = counter / 10;
            len = len + 1;
        }
    }
    
    let is String as s;
    s.len = cast(i32, len);
    s.cap = cast(i32, len);
    s.ptr = cast(*u8, galloc(len + 1));
    
    let is i64 as i with mut = len - 1;
    if (n == 0) {
        let is *u8 as p = s.ptr;
        p[0] = 48; // '0'
    } else {
        let is i64 as val with mut = temp;
        while (val > 0) {
            let is i64 as digit = val % 10;
            let is *u8 as p = s.ptr;
            p[i] = cast(u8, digit + 48);
            val = val / 10;
            i = i - 1;
        }
        
        if (is_neg == 1) {
            let is *u8 as p = s.ptr;
            p[0] = 45; // '-'
        }
    }
    
    // Null terminate
    let is i64 as end_addr = cast(i64, s.ptr) + len;
    let is *u8 as end_ptr = cast(*u8, end_addr);
    end_ptr[0] = 0;

    return s;
}