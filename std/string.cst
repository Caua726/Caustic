use "mem.cst" as mem;
use "linux.cst" as linux;

struct String {
    ptr as *u8;
    len as i32;
    cap as i32;   
}

fn strlen( s as *u8) as i64 {
    let is i64 as i with mut = 0;
    while (s[i] != 0) {
        i = i + 1;
    }
    return i;
}

fn getbeforevalue() as *String {
    let is *String as ctx;
    asm("mov rax, r10");
    return cast(*String, ctx);
}

fn String(text as *u8) as String {
    // 1. Quem vai receber esse valor?
    let is *String as target = getbeforevalue();
    let is i64 as l = strlen(text);
    
    let is i32 as new_len = cast(i32, l);
    let is String as s;

    // 2. É uma Atribuição? (Target != 0)
    if (cast(i64, target) != 0) {
        
        // OTIMIZAÇÃO: Reutilizar memória se couber
        // Se o alvo já tem um buffer válido E cabe o texto novo...
        if (cast(i64, target.ptr) != 0 && target.cap >= new_len) {
            // Copia para o buffer JÁ EXISTENTE do alvo
            mem.memcpy(target.ptr, text, l);
            target.ptr[l] = cast(u8, 0);
            
            // Retorna uma struct configurada para MANTER esse ponteiro
            s.ptr = target.ptr;
            s.cap = target.cap; // Mantém a capacidade grande
            s.len = new_len;
            
            // O operador '=' vai sobrescrever a struct na stack, 
            // mas o ponteiro no heap foi preservado e reutilizado!
            return s;
        }

        // Se não cabe ou é inválido, TEMOS que limpar o antigo
        if (cast(i64, target.ptr) != 0) {
            mem.gfree(target.ptr);
        }
    }

    // 3. Alocação Padrão (Declaração ou Atribuição que estourou capacidade)
    s.len = new_len;
    s.cap = new_len; // Aloca exato (Fit)
    
    if (l > 0) {
        s.ptr = cast(*u8, mem.galloc(l + 1));
        mem.memcpy(s.ptr, text, l);
        s.ptr[l] = cast(u8, 0);
    } else {
        s.ptr = cast(*u8, 0);
    }
    
    return s;
}

// Função manual caso queira limpar antes de sair do escopo
fn string_free(s as String) as void {
    if (cast(i64, s.ptr) != 0) {
        mem.gfree(s.ptr);
    }
}

fn concat(s1 as String, s2 as String) as String {
    let is i64 as l1 = cast(i64, s1.len);
    let is i64 as l2 = cast(i64, s2.len);
    let is i64 as total_len = l1 + l2;
    
    let is String as new_s;
    new_s.len = cast(i32, total_len);
    new_s.cap = cast(i32, total_len);
    
    if (total_len > 0) {
        new_s.ptr = cast(*u8, mem.galloc(total_len + 1));
        
        if (l1 > 0) {
            mem.memcpy(new_s.ptr, s1.ptr, l1);
        }
        
        if (l2 > 0) {
            let is i64 as dest_addr = cast(i64, new_s.ptr) + l1;
            mem.memcpy(cast(*u8, dest_addr), s2.ptr, l2);
        }
        
        // Null terminate
        let is i64 as end_addr = cast(i64, new_s.ptr) + total_len;
        let is *u8 as end_ptr = cast(*u8, end_addr);
        end_ptr[0] = 0; 
    } else {
        new_s.ptr = cast(*u8, 0);
    }
    
    return new_s;
}

fn int_to_string(n as i64) as String {
    let is i64 as temp with mut = n;
    let is i64 as len with mut = 0;
    let is i64 as is_neg with mut = 0;
    
    if (n == 0) {
        len = 1;
    } else {
        if (n < 0) {
            is_neg = 1;
            temp = 0 - n;
            len = len + 1;
        }
        
        let is i64 as counter with mut = temp;
        while (counter > 0) {
            counter = counter / 10;
            len = len + 1;
        }
    }
    
    let is String as s;
    s.len = cast(i32, len);
    s.cap = cast(i32, len);
    s.ptr = cast(*u8, mem.galloc(len + 1));
    
    let is i64 as i with mut = len - 1;
    if (n == 0) {
        let is *u8 as p = s.ptr;
        p[0] = 48; // '0'
    } else {
        let is i64 as val with mut = temp;
        while (val > 0) {
            let is i64 as digit = val % 10;
            let is *u8 as p = s.ptr;
            p[i] = cast(u8, digit + 48);
            val = val / 10;
            i = i - 1;
        }
        
        if (is_neg == 1) {
            let is *u8 as p = s.ptr;
            p[0] = 45; // '-'
        }
    }
    
    // Null terminate
    let is i64 as end_addr = cast(i64, s.ptr) + len;
    let is *u8 as end_ptr = cast(*u8, end_addr);
    end_ptr[0] = 0;

    return s;
}

fn int_to_string_in(h as *mem.Heap, n as i64) as String {
    let is i64 as temp with mut = n;
    let is i64 as len with mut = 0;
    let is i64 as is_neg with mut = 0;
    
    if (n == 0) {
        len = 1;
    } else {
        if (n < 0) {
            is_neg = 1;
            temp = 0 - n;
            len = len + 1;
        }
        
        let is i64 as counter with mut = temp;
        while (counter > 0) {
            counter = counter / 10;
            len = len + 1;
        }
    }
    
    let is String as s;
    s.len = cast(i32, len);
    s.cap = cast(i32, len);
    s.ptr = cast(*u8, mem.alloc(h, len + 1));
    
    let is i64 as i with mut = len - 1;
    if (n == 0) {
        let is *u8 as p = s.ptr;
        p[0] = 48; // '0'
    } else {
        let is i64 as val with mut = temp;
        while (val > 0) {
            let is i64 as digit = val % 10;
            let is *u8 as p = s.ptr;
            p[i] = cast(u8, digit + 48);
            val = val / 10;
            i = i - 1;
        }
        
        if (is_neg == 1) {
            let is *u8 as p = s.ptr;
            p[0] = 45; // '-'
        }
    }
    
    // Null terminate
    let is i64 as end_addr = cast(i64, s.ptr) + len;
    let is *u8 as end_ptr = cast(*u8, end_addr);
    end_ptr[0] = cast(u8, 0);

    return s;
}

// Retorna índice da primeira ocorrência de needle em haystack, ou -1
fn find(haystack as String, needle as String) as i32 {
    if (needle.len == 0) { return cast(i32, 0); }
    if (haystack.len < needle.len) { return cast(i32, 0 - 1); }

    let is i32 as limit = haystack.len - needle.len;
    let is i32 as i with mut = 0;

    while (i <= limit) {
        let is i32 as j with mut = 0;
        let is i32 as found with mut = 1;

        while (j < needle.len) {
            // Pointer arithmetic: base + i + j
            if (haystack.ptr[i + j] != needle.ptr[j]) {
                found = 0;
                break;
            }
            j = j + 1;
        }

        if (found == 1) {
            return i;
        }
        i = i + 1;
    }

    return cast(i32, 0 - 1);
}

fn find_from(haystack as String, needle as String, start_index as i32) as i32 {
    if (needle.len == 0) { return start_index; }
    if (haystack.len < needle.len) { return cast(i32, 0 - 1); }
    if (start_index >= haystack.len) { return cast(i32, 0 - 1); }

    let is i32 as limit = haystack.len - needle.len;
    let is i32 as i with mut = start_index;

    while (i <= limit) {
        let is i32 as j with mut = 0;
        let is i32 as found with mut = 1;

        while (j < needle.len) {
            if (haystack.ptr[i + j] != needle.ptr[j]) {
                found = 0;
                break;
            }
            j = j + 1;
        }

        if (found == 1) {
            return i;
        }
        i = i + 1;
    }

    return cast(i32, 0 - 1);
}

// Cria uma NOVA string (cópia) do slice [start, end)
// Aloca na heap fornecida
fn substring_in(h as *mem.Heap, s as String, start as i32, end as i32) as String {
    let is i32 as real_start with mut = start;
    let is i32 as real_end with mut = end;

    // Clamping básico para evitar segfault (segurança mínima)
    if (real_start < 0) { real_start = 0; }
    if (real_end > s.len) { real_end = s.len; }
    if (real_start > real_end) { real_start = real_end; }

    let is i32 as new_len = real_end - real_start;
    
    let is String as res;
    res.len = new_len;
    res.cap = new_len;

    if (new_len > 0) {
        res.ptr = cast(*u8, mem.alloc(h, cast(i64, new_len) + 1));
        
        // Aritmética de ponteiros: ptr + start
        let is i64 as src_addr = cast(i64, s.ptr) + cast(i64, real_start);
        
        mem.memcpy(res.ptr, cast(*u8, src_addr), cast(i64, new_len));
        res.ptr[new_len] = 0; // Null terminator vital para Linux
    } else {
        res.ptr = cast(*u8, 0);
    }

    return res;
}

fn eq(a as String, b as String) as i32 {
    if (a.len != b.len) { return 0; }
    let is i32 as i with mut = 0;
    while (i < a.len) {
        if (a.ptr[i] != b.ptr[i]) { return 0; }
        i = i + 1;
    }
    return 1;
}

fn starts_with(s as String, prefix as String) as i32 {
    if (prefix.len > s.len) { return 0; }
    let is i32 as i with mut = 0;
    while (i < prefix.len) {
        if (s.ptr[i] != prefix.ptr[i]) { return 0; }
        i = i + 1;
    }
    return 1;
}

fn ends_with(s as String, suffix as String) as i32 {
    if (suffix.len > s.len) { return 0; }
    let is i32 as offset = s.len - suffix.len;
    let is i32 as i with mut = 0;
    while (i < suffix.len) {
        if (s.ptr[offset + i] != suffix.ptr[i]) { return 0; }
        i = i + 1;
    }
    return 1;
}

fn contains(s as String, needle as String) as i32 {
    let is i32 as idx = find(s, needle);
    if (idx >= 0) { return 1; }
    return 0;
}

fn char_at(s as String, index as i32) as u8 {
    if (index < 0) { return cast(u8, 0); }
    if (index >= s.len) { return cast(u8, 0); }
    return s.ptr[index];
}

fn parse_int(s as String) as i64 {
    let is i64 as result with mut = 0;
    let is i32 as i with mut = 0;
    let is i64 as neg with mut = 0;

    if (s.len > 0 && s.ptr[0] == 45) {
        neg = 1;
        i = 1;
    }

    while (i < s.len) {
        let is u8 as c = s.ptr[i];
        if (c < 48) { break; }
        if (c > 57) { break; }
        result = result * 10 + cast(i64, c) - 48;
        i = i + 1;
    }

    if (neg == 1) { result = 0 - result; }
    return result;
}