use "../std/mem.cst" as mem;
use "../std/linux.cst" as linux;
use "elf_reader.cst" as reader;

// ============================================================
// linker.cst — Core linking logic
// Merge sections, resolve symbols, apply relocations
// ============================================================

// ============================================================
// Global symbol table
// ============================================================

struct GlobalSym {
    name as *u8;
    name_len as i32;
    section as i32;     // 1=text, 2=data, 3=rodata, 4=bss, 0=undef
    vaddr as i64;       // final virtual address
    obj_idx as i32;     // which .o file defined this
    defined as i32;     // 1 if defined, 0 if undefined
}

struct GlobalSymTab {
    data as *u8;
    count as i32;
    cap as i32;
}

fn gsym_init() as GlobalSymTab {
    let is GlobalSymTab as st;
    st.cap = 256;
    st.data = mem.galloc(cast(i64, st.cap) * sizeof(GlobalSym));
    st.count = 0;
    return st;
}

fn gsym_get(st as *GlobalSymTab, idx as i32) as *GlobalSym {
    return cast(*GlobalSym, cast(i64, st.data) + cast(i64, idx) * sizeof(GlobalSym));
}

fn gsym_find(st as *GlobalSymTab, name as *u8, name_len as i32) as i32 {
    let is i32 as i with mut = 0;
    while (i < st.count) {
        let is *GlobalSym as g = gsym_get(st, i);
        if (reader.streq(g.name, g.name_len, name, name_len) == 1) {
            return i;
        }
        i = i + 1;
    }
    return cast(i32, 0 - 1);
}

fn gsym_add(st as *GlobalSymTab, name as *u8, name_len as i32, section as i32,
            vaddr as i64, obj_idx as i32, defined as i32) as i32 {
    if (st.count >= st.cap) {
        let is i32 as new_cap = st.cap * 2;
        let is *u8 as new_data = mem.galloc(cast(i64, new_cap) * sizeof(GlobalSym));
        mem.memcpy(new_data, st.data, cast(i64, st.count) * sizeof(GlobalSym));
        mem.gfree(st.data);
        st.data = new_data;
        st.cap = new_cap;
    }
    let is *GlobalSym as g = gsym_get(st, st.count);
    g.name = name;
    g.name_len = name_len;
    g.section = section;
    g.vaddr = vaddr;
    g.obj_idx = obj_idx;
    g.defined = defined;
    st.count = st.count + 1;
    return st.count - 1;
}

// ============================================================
// Linker state
// ============================================================

struct LinkerState {
    text as *u8;        // *reader.ByteBuffer
    rodata as *u8;      // *reader.ByteBuffer
    data_sec as *u8;    // *reader.ByteBuffer
    bss_total as i64;

    base_addr as i64;
    text_vaddr as i64;
    rodata_vaddr as i64;
    data_vaddr as i64;
    bss_vaddr as i64;

    text_size as i64;
    rodata_size as i64;
    data_size as i64;

    gsyms as *u8;       // *GlobalSymTab
    objs as *u8;        // array of *ObjFile pointers
    obj_count as i32;

    entry_name as *u8;
    entry_vaddr as i64;
    verbose as i32;
    do_strip as i32;
    do_map as i32;
    keep_empty as i32;

    // Dynamic linking
    needed_libs as *u8;     // array of *u8 c-strings (lib names like "libc.so.6")
    needed_count as i32;
    dynsyms as *u8;         // *DynSymTab
    plt_buf as *u8;         // *reader.ByteBuffer — PLT stubs
    got_buf as *u8;         // *reader.ByteBuffer — GOT.PLT entries
    interp_buf as *u8;      // *reader.ByteBuffer — .interp
    dynsym_buf as *u8;      // *reader.ByteBuffer — .dynsym
    dynstr_buf as *u8;      // *reader.ByteBuffer — .dynstr
    hash_buf as *u8;        // *reader.ByteBuffer — .hash
    relaplt_buf as *u8;     // *reader.ByteBuffer — .rela.plt
    dynamic_buf as *u8;     // *reader.ByteBuffer — .dynamic
    data_got_buf as *u8;    // *reader.ByteBuffer — .got (for GOTPCREL data globals)
    reladyn_buf as *u8;     // *reader.ByteBuffer — .rela.dyn (GLOB_DAT entries)
}

fn alloc_bytebuf(cap as i64) as *u8 {
    let is *u8 as p = mem.galloc(sizeof(reader.ByteBuffer));
    let is *reader.ByteBuffer as bb = cast(*reader.ByteBuffer, p);
    let is reader.ByteBuffer as tmp = reader.buf_init(cap);
    bb.data = tmp.data;
    bb.len = tmp.len;
    bb.cap = tmp.cap;
    return p;
}

fn get_text(ls as *LinkerState) as *reader.ByteBuffer {
    return cast(*reader.ByteBuffer, ls.text);
}
fn get_rodata(ls as *LinkerState) as *reader.ByteBuffer {
    return cast(*reader.ByteBuffer, ls.rodata);
}
fn get_data(ls as *LinkerState) as *reader.ByteBuffer {
    return cast(*reader.ByteBuffer, ls.data_sec);
}
fn get_gsyms(ls as *LinkerState) as *GlobalSymTab {
    return cast(*GlobalSymTab, ls.gsyms);
}

fn linker_init(base_addr as i64) as LinkerState {
    let is LinkerState as ls;
    ls.text = alloc_bytebuf(65536);
    ls.rodata = alloc_bytebuf(4096);
    ls.data_sec = alloc_bytebuf(4096);
    ls.bss_total = 0;
    ls.base_addr = base_addr;
    ls.text_vaddr = 0;
    ls.rodata_vaddr = 0;
    ls.data_vaddr = 0;
    ls.bss_vaddr = 0;
    ls.text_size = 0;
    ls.rodata_size = 0;
    ls.data_size = 0;
    let is *u8 as gs = mem.galloc(sizeof(GlobalSymTab));
    let is *GlobalSymTab as gst = cast(*GlobalSymTab, gs);
    let is GlobalSymTab as tmp_gs = gsym_init();
    gst.data = tmp_gs.data;
    gst.count = tmp_gs.count;
    gst.cap = tmp_gs.cap;
    ls.gsyms = gs;
    ls.objs = cast(*u8, 0);
    ls.obj_count = 0;
    ls.entry_name = "main";
    ls.entry_vaddr = 0;
    ls.verbose = 0;
    ls.do_strip = 0;
    ls.do_map = 0;
    ls.keep_empty = 0;
    ls.needed_libs = cast(*u8, 0);
    ls.needed_count = 0;
    ls.dynsyms = cast(*u8, 0);
    ls.plt_buf = cast(*u8, 0);
    ls.got_buf = cast(*u8, 0);
    ls.interp_buf = cast(*u8, 0);
    ls.dynsym_buf = cast(*u8, 0);
    ls.dynstr_buf = cast(*u8, 0);
    ls.hash_buf = cast(*u8, 0);
    ls.relaplt_buf = cast(*u8, 0);
    ls.dynamic_buf = cast(*u8, 0);
    ls.data_got_buf = cast(*u8, 0);
    ls.reladyn_buf = cast(*u8, 0);
    return ls;
}

fn get_obj(ls as *LinkerState, idx as i32) as *reader.ObjFile {
    let is *i64 as arr = cast(*i64, ls.objs);
    return cast(*reader.ObjFile, arr[idx]);
}

// ============================================================
// _start stub
// ============================================================

let is i32 as START_STUB_SIZE with imut = 20;
let is i32 as START_STUB_REL32_OFF with imut = 4;

fn emit_start_stub(buf as *reader.ByteBuffer) as void {
    reader.buf_emit8(buf, 72);  // xor rbp, rbp
    reader.buf_emit8(buf, 49);
    reader.buf_emit8(buf, 237);
    reader.buf_emit8(buf, 232); // call rel32
    reader.buf_emit32_le(buf, 0);
    reader.buf_emit8(buf, 72);  // mov rdi, rax
    reader.buf_emit8(buf, 137);
    reader.buf_emit8(buf, 199);
    reader.buf_emit8(buf, 72);  // mov rax, 60
    reader.buf_emit8(buf, 199);
    reader.buf_emit8(buf, 192);
    reader.buf_emit8(buf, 60);
    reader.buf_emit8(buf, 0);
    reader.buf_emit8(buf, 0);
    reader.buf_emit8(buf, 0);
    reader.buf_emit8(buf, 15);  // syscall
    reader.buf_emit8(buf, 5);
}

// ============================================================
// Phase 1: Merge sections
// ============================================================

fn merge_sections(ls as *LinkerState) as void {
    let is *reader.ByteBuffer as text_buf = get_text(ls);
    let is *reader.ByteBuffer as rodata_buf = get_rodata(ls);
    let is *reader.ByteBuffer as data_buf = get_data(ls);

    emit_start_stub(text_buf);

    let is i32 as i with mut = 0;
    while (i < ls.obj_count) {
        let is *reader.ObjFile as obj = get_obj(ls, i);

        obj.text_offset = text_buf.len;
        if (obj.text.size > 0) {
            reader.buf_append(text_buf, obj.text.data, obj.text.size);
        }

        obj.rodata_offset = rodata_buf.len;
        if (obj.rodata.size > 0) {
            reader.buf_append(rodata_buf, obj.rodata.data, obj.rodata.size);
        }

        obj.data_offset = data_buf.len;
        if (obj.data_sec.size > 0) {
            reader.buf_append(data_buf, obj.data_sec.data, obj.data_sec.size);
        }

        obj.bss_offset = ls.bss_total;
        ls.bss_total = ls.bss_total + obj.bss_size;

        i = i + 1;
    }

    ls.text_size = text_buf.len;
    ls.rodata_size = rodata_buf.len;
    ls.data_size = data_buf.len;
}

// ============================================================
// Phase 2: Assign virtual addresses
// ============================================================

fn assign_addresses(ls as *LinkerState) as void {
    ls.text_vaddr = ls.base_addr + 4096;
    ls.rodata_vaddr = ls.text_vaddr + ls.text_size;

    let is i64 as rx_end = ls.text_vaddr + ls.text_size + ls.rodata_size;
    ls.data_vaddr = rx_end;
    if (rx_end % 4096 != 0) {
        ls.data_vaddr = rx_end + 4096 - (rx_end % 4096);
    }
    ls.bss_vaddr = ls.data_vaddr + ls.data_size;
}

// ============================================================
// Phase 3: Build global symbol table
// ============================================================

fn resolve_sym_vaddr(ls as *LinkerState, obj as *reader.ObjFile,
                     section as i32, value as i64) as i64 {
    if (section == reader.SECIDX_TEXT) {
        return ls.text_vaddr + obj.text_offset + value;
    }
    if (section == reader.SECIDX_DATA) {
        return ls.data_vaddr + obj.data_offset + value;
    }
    if (section == reader.SECIDX_RODATA) {
        return ls.rodata_vaddr + obj.rodata_offset + value;
    }
    if (section == reader.SECIDX_BSS) {
        return ls.bss_vaddr + obj.bss_offset + value;
    }
    return 0;
}

fn build_symtab(ls as *LinkerState) as i32 {
    let is i32 as errors with mut = 0;
    let is *GlobalSymTab as gsyms = get_gsyms(ls);
    let is i32 as i with mut = 0;

    while (i < ls.obj_count) {
        let is *reader.ObjFile as obj = get_obj(ls, i);
        let is i32 as si with mut = 0;

        while (si < obj.sym_count) {
            let is *reader.ObjSym as sym = reader.sym_get(obj, si);

            if (si == 0 || sym.sym_type == reader.STT_SECTION) {
                // Skip null and section symbols
            } else if (sym.binding == reader.STB_GLOBAL && sym.section != 0) {
                let is i64 as vaddr = resolve_sym_vaddr(ls, obj, sym.section, sym.value);
                let is i32 as existing = gsym_find(gsyms, sym.name, sym.name_len);
                if (existing >= 0) {
                    let is *GlobalSym as eg = gsym_get(gsyms, existing);
                    if (eg.defined == 1) {
                        if (ls.verbose == 1) {
                            reader.print_str("warning: duplicate symbol: ");
                            linux.write(linux.STDERR, sym.name, cast(i64, sym.name_len));
                            reader.print_str("\n");
                        }
                    } else {
                        eg.section = sym.section;
                        eg.vaddr = vaddr;
                        eg.obj_idx = i;
                        eg.defined = 1;
                    }
                } else {
                    gsym_add(gsyms, sym.name, sym.name_len, sym.section, vaddr, i, 1);
                }
            } else if (sym.binding == reader.STB_GLOBAL && sym.section == 0) {
                let is i32 as existing = gsym_find(gsyms, sym.name, sym.name_len);
                if (existing < 0) {
                    gsym_add(gsyms, sym.name, sym.name_len, 0, 0, i, 0);
                }
            }

            si = si + 1;
        }
        i = i + 1;
    }

    // Check for unresolved symbols
    let is i32 as gi with mut = 0;
    while (gi < gsyms.count) {
        let is *GlobalSym as g = gsym_get(gsyms, gi);
        if (g.defined == 0 && ls.needed_count == 0) {
            reader.print_str("warning: undefined symbol: ");
            linux.write(linux.STDERR, g.name, cast(i64, g.name_len));
            reader.print_str("\n");
        }
        gi = gi + 1;
    }

    // Find entry point
    let is i32 as entry_name_len = reader.cstrlen(ls.entry_name);
    let is i32 as entry_idx = gsym_find(gsyms, ls.entry_name, entry_name_len);
    if (entry_idx < 0) {
        reader.print_str("error: entry point not found: ");
        reader.print_str(ls.entry_name);
        reader.print_str("\n");
        return 1;
    }
    let is *GlobalSym as entry_sym = gsym_get(gsyms, entry_idx);
    if (entry_sym.defined == 0) {
        reader.print_str("error: entry point undefined: ");
        reader.print_str(ls.entry_name);
        reader.print_str("\n");
        return 1;
    }

    let is i64 as main_vaddr = entry_sym.vaddr;

    // Patch _start stub
    let is *reader.ByteBuffer as text_buf = get_text(ls);
    let is i64 as call_site = ls.text_vaddr + cast(i64, START_STUB_REL32_OFF) + 4;
    let is i64 as rel32 = main_vaddr - call_site;
    let is *u8 as tdata = text_buf.data;
    tdata[START_STUB_REL32_OFF]     = cast(u8, rel32 & 255);
    tdata[START_STUB_REL32_OFF + 1] = cast(u8, (rel32 >> 8) & 255);
    tdata[START_STUB_REL32_OFF + 2] = cast(u8, (rel32 >> 16) & 255);
    tdata[START_STUB_REL32_OFF + 3] = cast(u8, (rel32 >> 24) & 255);

    ls.entry_vaddr = ls.text_vaddr;

    return errors;
}

// ============================================================
// Phase 4: Apply relocations
// ============================================================

fn resolve_reloc_sym(ls as *LinkerState, obj as *reader.ObjFile, sym_idx as i32) as i64 {
    if (sym_idx < 0 || sym_idx >= obj.sym_count) {
        return 0;
    }
    let is *reader.ObjSym as sym = reader.sym_get(obj, sym_idx);

    if (sym.sym_type == reader.STT_SECTION) {
        if (sym.section == reader.SECIDX_TEXT) {
            return ls.text_vaddr + obj.text_offset;
        }
        if (sym.section == reader.SECIDX_DATA) {
            return ls.data_vaddr + obj.data_offset;
        }
        if (sym.section == reader.SECIDX_RODATA) {
            return ls.rodata_vaddr + obj.rodata_offset;
        }
        if (sym.section == reader.SECIDX_BSS) {
            return ls.bss_vaddr + obj.bss_offset;
        }
        return 0;
    }

    if (sym.binding == reader.STB_LOCAL && sym.section != 0) {
        return resolve_sym_vaddr(ls, obj, sym.section, sym.value);
    }

    if (sym.name_len > 0) {
        // Check if this is a dynamic symbol first
        if (is_dynamic_sym(ls, sym.name, sym.name_len) == 1) {
            return get_plt_vaddr(ls, sym.name, sym.name_len);
        }

        let is *GlobalSymTab as gsyms = get_gsyms(ls);
        let is i32 as gi = gsym_find(gsyms, sym.name, sym.name_len);
        if (gi >= 0) {
            let is *GlobalSym as g = gsym_get(gsyms, gi);
            return g.vaddr;
        }
    }

    return 0;
}

fn apply_relocations(ls as *LinkerState) as void {
    let is *reader.ByteBuffer as text_buf = get_text(ls);
    let is *reader.ByteBuffer as data_buf = get_data(ls);
    let is i32 as i with mut = 0;

    while (i < ls.obj_count) {
        let is *reader.ObjFile as obj = get_obj(ls, i);
        let is i32 as ri with mut = 0;

        while (ri < obj.reloc_count) {
            let is *reader.ObjReloc as rel = reader.reloc_get(obj, ri);

            let is i64 as S = resolve_reloc_sym(ls, obj, rel.sym_idx);
            let is i64 as A = rel.addend;
            let is i64 as P with mut = 0;
            let is *u8 as target_data with mut = cast(*u8, 0);
            let is i64 as buf_offset with mut = 0;

            if (rel.section == reader.SECIDX_TEXT) {
                P = ls.text_vaddr + obj.text_offset + rel.offset;
                target_data = text_buf.data;
                buf_offset = obj.text_offset + rel.offset;
            }
            else if (rel.section == reader.SECIDX_DATA) {
                P = ls.data_vaddr + obj.data_offset + rel.offset;
                target_data = data_buf.data;
                buf_offset = obj.data_offset + rel.offset;
            }

            if (cast(i64, target_data) != 0) {
                if (rel.rtype == reader.R_X86_64_PC32 || rel.rtype == reader.R_X86_64_PLT32) {
                    let is i64 as value = S + A - P;
                    if (value > 2147483647 || value < (0 - 2147483648)) {
                        if (ls.verbose == 1) {
                            reader.print_str("warning: relocation overflow at ");
                            reader.print_hex(P);
                            reader.print_str("\n");
                        }
                    }
                    target_data[buf_offset]     = cast(u8, value & 255);
                    target_data[buf_offset + 1] = cast(u8, (value >> 8) & 255);
                    target_data[buf_offset + 2] = cast(u8, (value >> 16) & 255);
                    target_data[buf_offset + 3] = cast(u8, (value >> 24) & 255);
                }
                else if (rel.rtype == reader.R_X86_64_GOTPCREL) {
                    // S = data GOT entry vaddr for this symbol
                    let is *reader.ObjSym as sym = reader.sym_get(obj, rel.sym_idx);
                    let is i64 as got_addr = get_data_got_vaddr(ls, sym.name, sym.name_len);
                    let is i64 as value = got_addr + A - P;
                    target_data[buf_offset]     = cast(u8, value & 255);
                    target_data[buf_offset + 1] = cast(u8, (value >> 8) & 255);
                    target_data[buf_offset + 2] = cast(u8, (value >> 16) & 255);
                    target_data[buf_offset + 3] = cast(u8, (value >> 24) & 255);
                }
            }

            ri = ri + 1;
        }
        i = i + 1;
    }
}

// ============================================================
// Map file generation
// ============================================================

fn write_map(ls as *LinkerState, output_path as *u8) as void {
    let is i64 as path_len = reader.strlen(output_path);
    let is *u8 as map_path = mem.galloc(path_len + 5);
    mem.memcpy(map_path, output_path, path_len);
    map_path[path_len] = 46;
    map_path[path_len + 1] = 109;
    map_path[path_len + 2] = 97;
    map_path[path_len + 3] = 112;
    map_path[path_len + 4] = 0;

    let is i64 as fd = linux.open(map_path, 577, 420);
    if (fd < 0) {
        reader.print_str("warning: cannot create map file\n");
        mem.gfree(map_path);
        return;
    }

    linux.write(fd, "Address            Type  Name\n", 30);
    linux.write(fd, "----------------------------------------------\n", 47);

    write_map_entry(fd, ls.text_vaddr, 84, "_start");

    let is *GlobalSymTab as gsyms = get_gsyms(ls);
    let is i32 as gi with mut = 0;
    while (gi < gsyms.count) {
        let is *GlobalSym as g = gsym_get(gsyms, gi);
        if (g.defined == 1) {
            let is i32 as type_char with mut = 84;
            if (g.section == reader.SECIDX_DATA) { type_char = 68; }
            if (g.section == reader.SECIDX_RODATA) { type_char = 82; }
            if (g.section == reader.SECIDX_BSS) { type_char = 66; }
            write_map_entry(fd, g.vaddr, type_char, g.name);
        }
        gi = gi + 1;
    }

    linux.close(fd);
    mem.gfree(map_path);
}

fn write_hex_to_fd(fd as i64, val as i64) as void {
    let is *u8 as hex = "0123456789abcdef";
    let is [18]u8 as buf;
    buf[0] = 48;
    buf[1] = 120;
    let is i64 as vi with mut = 0;
    let is i64 as v with mut = val;
    while (vi < 16) {
        buf[17 - vi] = hex[v & 15];
        v = v >> 4;
        vi = vi + 1;
    }
    linux.write(fd, &buf[0], 18);
}

fn write_map_entry(fd as i64, addr as i64, type_char as i32, name as *u8) as void {
    write_hex_to_fd(fd, addr);
    linux.write(fd, "  ", 2);
    let is u8 as tc = cast(u8, type_char);
    linux.write(fd, &tc, 1);
    linux.write(fd, "     ", 5);
    linux.write(fd, name, reader.strlen(name));
    linux.write(fd, "\n", 1);
}

// ============================================================
// Dynamic linking support
// ============================================================

struct DynSym {
    name as *u8;
    name_len as i32;
    plt_vaddr as i64;
    got_vaddr as i64;
    data_got_vaddr as i64; // for GOTPCREL (data globals like stdout)
    is_data as i32;        // 1 = data object (GOT), 0 = function (PLT)
    dynsym_index as i32;   // index in .dynsym (1-based, 0 is null)
    dynstr_offset as i32;  // offset of name in .dynstr
}

struct DynSymTab {
    data as *u8;
    count as i32;
    cap as i32;
}

fn dynsym_init() as DynSymTab {
    let is DynSymTab as st;
    st.cap = 64;
    st.data = mem.galloc(cast(i64, st.cap) * sizeof(DynSym));
    st.count = 0;
    return st;
}

fn dynsym_get(st as *DynSymTab, idx as i32) as *DynSym {
    return cast(*DynSym, cast(i64, st.data) + cast(i64, idx) * sizeof(DynSym));
}

fn dynsym_add(st as *DynSymTab, name as *u8, name_len as i32) as i32 {
    if (st.count >= st.cap) {
        let is i32 as new_cap = st.cap * 2;
        let is *u8 as new_data = mem.galloc(cast(i64, new_cap) * sizeof(DynSym));
        mem.memcpy(new_data, st.data, cast(i64, st.count) * sizeof(DynSym));
        mem.gfree(st.data);
        st.data = new_data;
        st.cap = new_cap;
    }
    let is *DynSym as d = dynsym_get(st, st.count);
    d.name = name;
    d.name_len = name_len;
    d.plt_vaddr = 0;
    d.got_vaddr = 0;
    d.data_got_vaddr = 0;
    d.is_data = 0;
    d.dynsym_index = 0;
    d.dynstr_offset = 0;
    st.count = st.count + 1;
    return st.count - 1;
}

fn dynsym_find(st as *DynSymTab, name as *u8, name_len as i32) as i32 {
    let is i32 as i with mut = 0;
    while (i < st.count) {
        let is *DynSym as d = dynsym_get(st, i);
        if (reader.streq(d.name, d.name_len, name, name_len) == 1) {
            return i;
        }
        i = i + 1;
    }
    return cast(i32, 0 - 1);
}

fn get_dynsyms(ls as *LinkerState) as *DynSymTab {
    return cast(*DynSymTab, ls.dynsyms);
}

// Collect undefined globals that should become dynamic symbols
fn collect_dynamic_syms(ls as *LinkerState) as void {
    let is *u8 as ds = mem.galloc(sizeof(DynSymTab));
    let is *DynSymTab as dst = cast(*DynSymTab, ds);
    let is DynSymTab as tmp = dynsym_init();
    dst.data = tmp.data;
    dst.count = tmp.count;
    dst.cap = tmp.cap;
    ls.dynsyms = ds;

    let is *GlobalSymTab as gsyms = get_gsyms(ls);
    let is i32 as gi with mut = 0;
    while (gi < gsyms.count) {
        let is *GlobalSym as g = gsym_get(gsyms, gi);
        if (g.defined == 0) {
            dynsym_add(dst, g.name, g.name_len);
            if (ls.verbose == 1) {
                reader.print_str("  dynamic sym: ");
                linux.write(linux.STDERR, g.name, cast(i64, g.name_len));
                reader.print_str("\n");
            }
        }
        gi = gi + 1;
    }

    // Scan relocations to detect GOTPCREL symbols (data objects)
    let is i32 as oi with mut = 0;
    while (oi < ls.obj_count) {
        let is *reader.ObjFile as obj = get_obj(ls, oi);
        let is i32 as ri with mut = 0;
        while (ri < obj.reloc_count) {
            let is *reader.ObjReloc as rel = reader.reloc_get(obj, ri);
            if (rel.rtype == reader.R_X86_64_GOTPCREL) {
                let is *reader.ObjSym as sym = reader.sym_get(obj, rel.sym_idx);
                if (sym.name_len > 0) {
                    let is i32 as di = dynsym_find(dst, sym.name, sym.name_len);
                    if (di >= 0) {
                        let is *DynSym as d = dynsym_get(dst, di);
                        d.is_data = 1;
                    }
                }
            }
            ri = ri + 1;
        }
        oi = oi + 1;
    }
}

// ELF hash algorithm
fn elf_hash(name as *u8, len as i32) as i64 {
    let is i64 as h with mut = 0;
    let is i32 as i with mut = 0;
    while (i < len) {
        h = (h << 4) + cast(i64, name[i]);
        let is i64 as g = h & cast(i64, 4026531840); // 0xF0000000
        if (g != 0) {
            h = h ^ (g >> 24);
        }
        h = h & 268435455; // 0x0FFFFFFF
        i = i + 1;
    }
    return h;
}

// Build .interp, .dynsym, .dynstr, .hash, .rela.plt, .dynamic sections
// PLT/GOT addresses must be known before calling this (set by layout calc)
fn build_dynamic_metadata(ls as *LinkerState,
                          plt_vaddr as i64, got_vaddr as i64,
                          interp_vaddr as i64, dynsym_vaddr as i64,
                          dynstr_vaddr as i64, hash_vaddr as i64,
                          relaplt_vaddr as i64, dynamic_vaddr as i64,
                          reladyn_vaddr as i64) as void {
    let is *DynSymTab as dst = get_dynsyms(ls);
    let is i32 as ndynsyms = dst.count;

    // --- .interp ---
    let is *reader.ByteBuffer as interp = cast(*reader.ByteBuffer, ls.interp_buf);
    reader.buf_append(interp, "/lib64/ld-linux-x86-64.so.2", 28);

    // --- .dynstr ---
    let is *reader.ByteBuffer as dynstr = cast(*reader.ByteBuffer, ls.dynstr_buf);
    reader.buf_emit8(dynstr, 0);  // null entry

    // Add library names
    let is *i64 as lib_arr = cast(*i64, ls.needed_libs);
    let is [32]i32 as lib_offsets;
    let is i32 as li with mut = 0;
    while (li < ls.needed_count) {
        lib_offsets[li] = cast(i32, dynstr.len);
        let is *u8 as lib_name = cast(*u8, lib_arr[li]);
        let is i64 as lib_len = reader.strlen(lib_name);
        reader.buf_append(dynstr, lib_name, lib_len);
        reader.buf_emit8(dynstr, 0);
        li = li + 1;
    }

    // Add symbol names
    let is i32 as di with mut = 0;
    while (di < ndynsyms) {
        let is *DynSym as d = dynsym_get(dst, di);
        d.dynstr_offset = cast(i32, dynstr.len);
        reader.buf_append(dynstr, d.name, cast(i64, d.name_len));
        reader.buf_emit8(dynstr, 0);
        di = di + 1;
    }

    // --- .dynsym ---
    let is *reader.ByteBuffer as dynsym = cast(*reader.ByteBuffer, ls.dynsym_buf);
    // Null entry (24 bytes)
    let is i32 as zi with mut = 0;
    while (zi < 24) { reader.buf_emit8(dynsym, 0); zi = zi + 1; }

    di = 0;
    while (di < ndynsyms) {
        let is *DynSym as d = dynsym_get(dst, di);
        d.dynsym_index = di + 1; // 1-based (0 is null)
        reader.buf_emit32_le(dynsym, cast(i64, d.dynstr_offset)); // st_name
        if (d.is_data == 1) {
            reader.buf_emit8(dynsym, 17);  // st_info: STB_GLOBAL(1)<<4 | STT_OBJECT(1) = 0x11
        } else {
            reader.buf_emit8(dynsym, 18);  // st_info: STB_GLOBAL(1)<<4 | STT_FUNC(2) = 0x12
        }
        reader.buf_emit8(dynsym, 0);   // st_other
        reader.buf_emit16_le(dynsym, 0);  // st_shndx: SHN_UNDEF
        reader.buf_emit64_le(dynsym, 0);  // st_value
        reader.buf_emit64_le(dynsym, 0);  // st_size
        di = di + 1;
    }

    // --- .hash ---
    let is *reader.ByteBuffer as hash = cast(*reader.ByteBuffer, ls.hash_buf);
    let is i32 as nchain = ndynsyms + 1; // including null sym
    let is i32 as nbucket with mut = ndynsyms;
    if (nbucket < 1) { nbucket = 1; }
    reader.buf_emit32_le(hash, cast(i64, nbucket));
    reader.buf_emit32_le(hash, cast(i64, nchain));

    // Init buckets to 0 (STN_UNDEF = "no symbol")
    let is i32 as bi with mut = 0;
    while (bi < nbucket) {
        reader.buf_emit32_le(hash, 0);
        bi = bi + 1;
    }
    // Init chain to 0
    let is i32 as ci with mut = 0;
    while (ci < nchain) {
        reader.buf_emit32_le(hash, 0);
        ci = ci + 1;
    }

    // Populate hash table
    // We need to patch bucket/chain entries in the buffer
    let is *u8 as hash_data = hash.data;
    di = 0;
    while (di < ndynsyms) {
        let is *DynSym as d = dynsym_get(dst, di);
        let is i64 as h = elf_hash(d.name, d.name_len);
        let is i32 as bucket_idx = cast(i32, h % cast(i64, nbucket));
        let is i32 as sym_idx = di + 1; // 1-based in dynsym

        // Read current bucket value
        let is i64 as bucket_off = 8 + cast(i64, bucket_idx) * 4;
        let is i64 as old_val = reader.read_u32(hash_data, bucket_off);

        if (old_val == 0) {
            // Empty bucket, point directly to this sym
            hash_data[bucket_off]     = cast(u8, sym_idx & 255);
            hash_data[bucket_off + 1] = cast(u8, (sym_idx >> 8) & 255);
            hash_data[bucket_off + 2] = cast(u8, (sym_idx >> 16) & 255);
            hash_data[bucket_off + 3] = cast(u8, (sym_idx >> 24) & 255);
        } else {
            // Chain: walk to end of chain, then append
            let is i32 as cur with mut = cast(i32, old_val);
            let is i64 as chain_off with mut = 8 + cast(i64, nbucket) * 4 + cast(i64, cur) * 4;
            let is i64 as next with mut = reader.read_u32(hash_data, chain_off);
            while (next != 0) {
                cur = cast(i32, next);
                chain_off = 8 + cast(i64, nbucket) * 4 + cast(i64, cur) * 4;
                next = reader.read_u32(hash_data, chain_off);
            }
            // Write sym_idx into chain[cur]
            hash_data[chain_off]     = cast(u8, sym_idx & 255);
            hash_data[chain_off + 1] = cast(u8, (sym_idx >> 8) & 255);
            hash_data[chain_off + 2] = cast(u8, (sym_idx >> 16) & 255);
            hash_data[chain_off + 3] = cast(u8, (sym_idx >> 24) & 255);
        }

        di = di + 1;
    }

    // --- .rela.plt --- (only function syms)
    let is *reader.ByteBuffer as relaplt = cast(*reader.ByteBuffer, ls.relaplt_buf);
    di = 0;
    while (di < ndynsyms) {
        let is *DynSym as d = dynsym_get(dst, di);
        if (d.is_data == 0) {
            // r_offset = GOT entry vaddr
            reader.buf_emit64_le(relaplt, d.got_vaddr);
            // r_info = (sym_index << 32) | R_X86_64_JUMP_SLOT(7)
            let is i64 as r_info = cast(i64, d.dynsym_index) * 4294967296 + 7;
            reader.buf_emit64_le(relaplt, r_info);
            // r_addend = 0
            reader.buf_emit64_le(relaplt, 0);
        }
        di = di + 1;
    }

    // --- .dynamic ---
    let is *reader.ByteBuffer as dynamic = cast(*reader.ByteBuffer, ls.dynamic_buf);

    // DT_NEEDED for each lib
    li = 0;
    while (li < ls.needed_count) {
        reader.buf_emit64_le(dynamic, 1);  // DT_NEEDED
        reader.buf_emit64_le(dynamic, cast(i64, lib_offsets[li]));
        li = li + 1;
    }

    // DT_HASH
    reader.buf_emit64_le(dynamic, 4);
    reader.buf_emit64_le(dynamic, hash_vaddr);

    // DT_STRTAB
    reader.buf_emit64_le(dynamic, 5);
    reader.buf_emit64_le(dynamic, dynstr_vaddr);

    // DT_SYMTAB
    reader.buf_emit64_le(dynamic, 6);
    reader.buf_emit64_le(dynamic, dynsym_vaddr);

    // DT_STRSZ
    reader.buf_emit64_le(dynamic, 10);
    reader.buf_emit64_le(dynamic, dynstr.len);

    // DT_SYMENT
    reader.buf_emit64_le(dynamic, 11);
    reader.buf_emit64_le(dynamic, 24);

    // DT_PLTGOT
    reader.buf_emit64_le(dynamic, 3);
    reader.buf_emit64_le(dynamic, got_vaddr);

    // DT_PLTRELSZ
    reader.buf_emit64_le(dynamic, 2);
    reader.buf_emit64_le(dynamic, relaplt.len);

    // DT_PLTREL = DT_RELA(7)
    reader.buf_emit64_le(dynamic, 20);
    reader.buf_emit64_le(dynamic, 7);

    // DT_JMPREL
    reader.buf_emit64_le(dynamic, 23);
    reader.buf_emit64_le(dynamic, relaplt_vaddr);

    // DT_FLAGS = DF_BIND_NOW(8)
    reader.buf_emit64_le(dynamic, 30);
    reader.buf_emit64_le(dynamic, 8);

    // .rela.dyn entries for data GOT (GLOB_DAT)
    let is i32 as ndata = count_data_dynsyms(ls);
    if (ndata > 0) {
        // DT_RELA (7)
        reader.buf_emit64_le(dynamic, 7);
        reader.buf_emit64_le(dynamic, reladyn_vaddr);
        // DT_RELASZ (8) — pre-calculated size
        reader.buf_emit64_le(dynamic, 8);
        reader.buf_emit64_le(dynamic, cast(i64, ndata) * 24);
        // DT_RELAENT (9)
        reader.buf_emit64_le(dynamic, 9);
        reader.buf_emit64_le(dynamic, 24);
    }

    // DT_NULL
    reader.buf_emit64_le(dynamic, 0);
    reader.buf_emit64_le(dynamic, 0);
}

// Build PLT stubs and GOT.PLT entries
// Must be called after assign_addresses and collect_dynamic_syms
// plt_base_vaddr = vaddr where PLT starts
// got_base_vaddr = vaddr where GOT.PLT starts
fn build_plt_got(ls as *LinkerState, plt_base_vaddr as i64, got_base_vaddr as i64) as void {
    let is *DynSymTab as dst = get_dynsyms(ls);
    let is i32 as ndynsyms = dst.count;
    let is *reader.ByteBuffer as plt = cast(*reader.ByteBuffer, ls.plt_buf);
    let is *reader.ByteBuffer as got = cast(*reader.ByteBuffer, ls.got_buf);

    // --- GOT.PLT: 3 reserved entries + 1 per dynamic sym ---
    // GOT[0] = .dynamic vaddr (set later by writer)
    reader.buf_emit64_le(got, 0);  // placeholder, patched by writer
    // GOT[1] = 0 (link_map, filled by dynamic linker)
    reader.buf_emit64_le(got, 0);
    // GOT[2] = 0 (_dl_runtime_resolve, filled by dynamic linker)
    reader.buf_emit64_le(got, 0);

    // --- PLT[0]: resolver stub (16 bytes) ---
    let is i64 as plt0_vaddr = plt_base_vaddr;
    // GOT[1] vaddr = got_base_vaddr + 8
    // GOT[2] vaddr = got_base_vaddr + 16
    let is i64 as got1_vaddr = got_base_vaddr + 8;
    let is i64 as got2_vaddr = got_base_vaddr + 16;

    // push QWORD [rip + disp_GOT1]  (FF 35 disp32)
    let is i64 as plt0_push_addr = plt0_vaddr + 6;  // after this instruction
    let is i64 as disp_got1 = got1_vaddr - plt0_push_addr;
    reader.buf_emit8(plt, 255);  // FF
    reader.buf_emit8(plt, 53);   // 35
    reader.buf_emit32_le(plt, disp_got1);

    // jmp QWORD [rip + disp_GOT2]  (FF 25 disp32)
    let is i64 as plt0_jmp_addr = plt0_vaddr + 12;  // after this instruction
    let is i64 as disp_got2 = got2_vaddr - plt0_jmp_addr;
    reader.buf_emit8(plt, 255);  // FF
    reader.buf_emit8(plt, 37);   // 25
    reader.buf_emit32_le(plt, disp_got2);

    // 4-byte NOP padding
    reader.buf_emit8(plt, 15);   // 0F
    reader.buf_emit8(plt, 31);   // 1F
    reader.buf_emit8(plt, 64);   // 40
    reader.buf_emit8(plt, 0);    // 00

    // --- PLT[n] entries (16 bytes each) — only for function syms ---
    let is i32 as di with mut = 0;
    let is i32 as plt_idx with mut = 0;
    while (di < ndynsyms) {
        let is *DynSym as d = dynsym_get(dst, di);
        if (d.is_data == 1) {
            // Data symbols don't get PLT entries
            di = di + 1;
            continue;
        }
        let is i64 as plt_entry_vaddr = plt_base_vaddr + 16 + cast(i64, plt_idx) * 16;
        let is i64 as got_entry_vaddr = got_base_vaddr + 24 + cast(i64, plt_idx) * 8;

        d.plt_vaddr = plt_entry_vaddr;
        d.got_vaddr = got_entry_vaddr;

        // GOT entry initially points to PLT[n]+6 (the push instruction — lazy fallback)
        reader.buf_emit64_le(got, plt_entry_vaddr + 6);

        // jmp QWORD [rip + disp_GOTn]  (FF 25 disp32)
        let is i64 as jmp_end = plt_entry_vaddr + 6;
        let is i64 as disp_gotn = got_entry_vaddr - jmp_end;
        reader.buf_emit8(plt, 255);  // FF
        reader.buf_emit8(plt, 37);   // 25
        reader.buf_emit32_le(plt, disp_gotn);

        // push n (relocation index)  (68 imm32)
        reader.buf_emit8(plt, 104);  // 68
        reader.buf_emit32_le(plt, cast(i64, plt_idx));

        // jmp PLT[0]  (E9 rel32)
        let is i64 as jmp_site = plt_entry_vaddr + 16;  // end of this instruction
        let is i64 as jmp_rel = plt0_vaddr - jmp_site;
        reader.buf_emit8(plt, 233);  // E9
        reader.buf_emit32_le(plt, jmp_rel);

        plt_idx = plt_idx + 1;
        di = di + 1;
    }
}

// Allocate all dynamic section buffers
fn alloc_dynamic_bufs(ls as *LinkerState) as void {
    ls.plt_buf = alloc_bytebuf(4096);
    ls.got_buf = alloc_bytebuf(4096);
    ls.interp_buf = alloc_bytebuf(64);
    ls.dynsym_buf = alloc_bytebuf(4096);
    ls.dynstr_buf = alloc_bytebuf(4096);
    ls.hash_buf = alloc_bytebuf(4096);
    ls.relaplt_buf = alloc_bytebuf(4096);
    ls.dynamic_buf = alloc_bytebuf(4096);
    ls.data_got_buf = alloc_bytebuf(4096);
    ls.reladyn_buf = alloc_bytebuf(4096);
}

// Check if a global symbol is dynamic (should be resolved via PLT)
fn is_dynamic_sym(ls as *LinkerState, name as *u8, name_len as i32) as i32 {
    if (ls.needed_count == 0) { return 0; }
    if (cast(i64, ls.dynsyms) == 0) { return 0; }
    let is *DynSymTab as dst = get_dynsyms(ls);
    let is i32 as idx = dynsym_find(dst, name, name_len);
    if (idx >= 0) { return 1; }
    return 0;
}

// Get PLT vaddr for a dynamic symbol
fn get_plt_vaddr(ls as *LinkerState, name as *u8, name_len as i32) as i64 {
    let is *DynSymTab as dst = get_dynsyms(ls);
    let is i32 as idx = dynsym_find(dst, name, name_len);
    if (idx >= 0) {
        let is *DynSym as d = dynsym_get(dst, idx);
        return d.plt_vaddr;
    }
    return 0;
}

// Get data GOT vaddr for a GOTPCREL dynamic symbol
fn get_data_got_vaddr(ls as *LinkerState, name as *u8, name_len as i32) as i64 {
    let is *DynSymTab as dst = get_dynsyms(ls);
    let is i32 as idx = dynsym_find(dst, name, name_len);
    if (idx >= 0) {
        let is *DynSym as d = dynsym_get(dst, idx);
        return d.data_got_vaddr;
    }
    return 0;
}

// Count data dynamic symbols (GOTPCREL)
fn count_data_dynsyms(ls as *LinkerState) as i32 {
    let is *DynSymTab as dst = get_dynsyms(ls);
    let is i32 as count with mut = 0;
    let is i32 as i with mut = 0;
    while (i < dst.count) {
        let is *DynSym as d = dynsym_get(dst, i);
        if (d.is_data == 1) { count = count + 1; }
        i = i + 1;
    }
    return count;
}

// Count function dynamic symbols (PLT)
fn count_func_dynsyms(ls as *LinkerState) as i32 {
    let is *DynSymTab as dst = get_dynsyms(ls);
    let is i32 as count with mut = 0;
    let is i32 as i with mut = 0;
    while (i < dst.count) {
        let is *DynSym as d = dynsym_get(dst, i);
        if (d.is_data == 0) { count = count + 1; }
        i = i + 1;
    }
    return count;
}

// Build data GOT entries for GOTPCREL symbols
fn build_data_got(ls as *LinkerState, data_got_base_vaddr as i64) as void {
    let is *DynSymTab as dst = get_dynsyms(ls);
    let is *reader.ByteBuffer as dgot = cast(*reader.ByteBuffer, ls.data_got_buf);
    let is i32 as slot with mut = 0;
    let is i32 as i with mut = 0;
    while (i < dst.count) {
        let is *DynSym as d = dynsym_get(dst, i);
        if (d.is_data == 1) {
            d.data_got_vaddr = data_got_base_vaddr + cast(i64, slot) * 8;
            // Emit 8 zero bytes (dynamic linker fills at runtime)
            reader.buf_emit64_le(dgot, 0);
            slot = slot + 1;
        }
        i = i + 1;
    }
}

// Build .rela.dyn with GLOB_DAT entries for data GOT symbols
fn build_rela_dyn(ls as *LinkerState) as void {
    let is *DynSymTab as dst = get_dynsyms(ls);
    let is *reader.ByteBuffer as rela = cast(*reader.ByteBuffer, ls.reladyn_buf);
    let is i32 as i with mut = 0;
    while (i < dst.count) {
        let is *DynSym as d = dynsym_get(dst, i);
        if (d.is_data == 1) {
            // r_offset = data GOT entry vaddr
            reader.buf_emit64_le(rela, d.data_got_vaddr);
            // r_info = (sym_index << 32) | R_X86_64_GLOB_DAT(6)
            let is i64 as r_info = (cast(i64, d.dynsym_index) << 32) + reader.R_X86_64_GLOB_DAT;
            reader.buf_emit64_le(rela, r_info);
            // r_addend = 0
            reader.buf_emit64_le(rela, 0);
        }
        i = i + 1;
    }
}
