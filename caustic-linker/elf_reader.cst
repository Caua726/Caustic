use "../std/mem.cst" as mem;
use "../std/linux.cst" as linux;

// ============================================================
// elf_reader.cst — Parse ELF64 relocatable object files (.o)
// ============================================================

// ELF constants
let is i32 as ET_REL with imut = 1;
let is i32 as EM_X86_64 with imut = 62;
let is i32 as SHT_NULL with imut = 0;
let is i32 as SHT_PROGBITS with imut = 1;
let is i32 as SHT_SYMTAB with imut = 2;
let is i32 as SHT_STRTAB with imut = 3;
let is i32 as SHT_RELA with imut = 4;
let is i32 as SHT_NOBITS with imut = 8;
let is i32 as SHF_WRITE with imut = 1;
let is i32 as SHF_ALLOC with imut = 2;
let is i32 as SHF_EXECINSTR with imut = 4;

// Symbol binding/type
let is i32 as STB_LOCAL with imut = 0;
let is i32 as STB_GLOBAL with imut = 1;
let is i32 as STT_NOTYPE with imut = 0;
let is i32 as STT_SECTION with imut = 3;

// Relocation types
let is i64 as R_X86_64_PC32 with imut = 2;
let is i64 as R_X86_64_PLT32 with imut = 4;

// Section indices in the .o files generated by caustic-as
let is i32 as SECIDX_TEXT with imut = 1;
let is i32 as SECIDX_DATA with imut = 2;
let is i32 as SECIDX_RODATA with imut = 3;
let is i32 as SECIDX_BSS with imut = 4;

// ============================================================
// ByteBuffer — reusable growable byte buffer
// ============================================================

struct ByteBuffer {
    data as *u8;
    len as i64;
    cap as i64;
}

fn buf_init(cap as i64) as ByteBuffer {
    let is ByteBuffer as b;
    b.data = mem.galloc(cap);
    b.len = 0;
    b.cap = cap;
    return b;
}

fn buf_ensure(b as *ByteBuffer, needed as i64) as void {
    if (b.len + needed > b.cap) {
        let is i64 as new_cap with mut = b.cap * 2;
        if (new_cap < b.len + needed) { new_cap = b.len + needed; }
        let is *u8 as new_data = mem.galloc(new_cap);
        mem.memcpy(new_data, b.data, b.len);
        mem.gfree(b.data);
        b.data = new_data;
        b.cap = new_cap;
    }
}

fn buf_emit8(b as *ByteBuffer, val as i32) as void {
    buf_ensure(b, 1);
    b.data[b.len] = cast(u8, val);
    b.len = b.len + 1;
}

fn buf_emit16_le(b as *ByteBuffer, val as i32) as void {
    buf_ensure(b, 2);
    b.data[b.len] = cast(u8, val & 255);
    b.data[b.len + 1] = cast(u8, (val >> 8) & 255);
    b.len = b.len + 2;
}

fn buf_emit32_le(b as *ByteBuffer, val as i64) as void {
    buf_ensure(b, 4);
    b.data[b.len]     = cast(u8, val & 255);
    b.data[b.len + 1] = cast(u8, (val >> 8) & 255);
    b.data[b.len + 2] = cast(u8, (val >> 16) & 255);
    b.data[b.len + 3] = cast(u8, (val >> 24) & 255);
    b.len = b.len + 4;
}

fn buf_emit64_le(b as *ByteBuffer, val as i64) as void {
    buf_ensure(b, 8);
    b.data[b.len]     = cast(u8, val & 255);
    b.data[b.len + 1] = cast(u8, (val >> 8) & 255);
    b.data[b.len + 2] = cast(u8, (val >> 16) & 255);
    b.data[b.len + 3] = cast(u8, (val >> 24) & 255);
    b.data[b.len + 4] = cast(u8, (val >> 32) & 255);
    b.data[b.len + 5] = cast(u8, (val >> 40) & 255);
    b.data[b.len + 6] = cast(u8, (val >> 48) & 255);
    b.data[b.len + 7] = cast(u8, (val >> 56) & 255);
    b.len = b.len + 8;
}

fn buf_append(dst as *ByteBuffer, src as *u8, len as i64) as void {
    buf_ensure(dst, len);
    mem.memcpy(cast(*u8, cast(i64, dst.data) + dst.len), src, len);
    dst.len = dst.len + len;
}

fn buf_align(b as *ByteBuffer, align as i64) as void {
    while (b.len % align != 0) {
        buf_emit8(b, 0);
    }
}

fn buf_pad_to(b as *ByteBuffer, target as i64) as void {
    while (b.len < target) {
        buf_emit8(b, 0);
    }
}

// ============================================================
// Read helpers — read little-endian values from raw bytes
// ============================================================

fn read_u8(ptr as *u8, off as i64) as i64 {
    return cast(i64, ptr[off]);
}

fn read_u16(ptr as *u8, off as i64) as i64 {
    return cast(i64, ptr[off]) + cast(i64, ptr[off + 1]) * 256;
}

fn read_i32(ptr as *u8, off as i64) as i64 {
    let is i64 as b0 = cast(i64, ptr[off]);
    let is i64 as b1 = cast(i64, ptr[off + 1]);
    let is i64 as b2 = cast(i64, ptr[off + 2]);
    let is i64 as b3 = cast(i64, ptr[off + 3]);
    let is i64 as val = b0 + b1 * 256 + b2 * 65536 + b3 * 16777216;
    // Sign extend from 32 bits
    if (b3 >= 128) {
        val = val - 4294967296;
    }
    return val;
}

fn read_u32(ptr as *u8, off as i64) as i64 {
    let is i64 as b0 = cast(i64, ptr[off]);
    let is i64 as b1 = cast(i64, ptr[off + 1]);
    let is i64 as b2 = cast(i64, ptr[off + 2]);
    let is i64 as b3 = cast(i64, ptr[off + 3]);
    return b0 + b1 * 256 + b2 * 65536 + b3 * 16777216;
}

fn read_u64(ptr as *u8, off as i64) as i64 {
    let is i64 as lo = read_u32(ptr, off);
    let is i64 as hi = read_u32(ptr, off + 4);
    return lo + hi * 4294967296;
}

// ============================================================
// String helpers
// ============================================================

fn strlen(s as *u8) as i64 {
    let is i64 as i with mut = 0;
    while (s[i] != 0) { i = i + 1; }
    return i;
}

fn streq(a as *u8, alen as i32, b as *u8, blen as i32) as i32 {
    if (alen != blen) { return 0; }
    let is i32 as i with mut = 0;
    while (i < alen) {
        if (a[i] != b[i]) { return 0; }
        i = i + 1;
    }
    return 1;
}

fn streq_cstr(a as *u8, b as *u8) as i32 {
    let is i64 as i with mut = 0;
    while (a[i] != 0 && b[i] != 0) {
        if (a[i] != b[i]) { return 0; }
        i = i + 1;
    }
    if (a[i] != b[i]) { return 0; }
    return 1;
}

// Compare c-string a against string literal b (null-terminated)
fn streq_lit(a as *u8, lit as *u8) as i32 {
    let is i64 as i with mut = 0;
    while (lit[i] != 0) {
        if (a[i] != lit[i]) { return 0; }
        i = i + 1;
    }
    if (a[i] != 0) { return 0; }
    return 1;
}

// Get pointer to null-terminated string in strtab at offset
fn strtab_get(strtab as *u8, off as i64) as *u8 {
    return cast(*u8, cast(i64, strtab) + off);
}

// Length of c-string
fn cstrlen(s as *u8) as i32 {
    let is i32 as i with mut = 0;
    while (s[i] != 0) { i = i + 1; }
    return i;
}

// ============================================================
// Parsed section info from one .o file
// ============================================================

struct ObjSection {
    data as *u8;       // pointer into file buffer
    size as i64;
    sh_offset as i64;  // file offset of section data
}

// A parsed symbol from one .o
struct ObjSym {
    name as *u8;       // pointer into strtab (null-terminated)
    name_len as i32;
    section as i32;    // section index (0 = undef, 1=text, 2=data, 3=rodata, 4=bss)
    value as i64;      // st_value (offset within section)
    binding as i32;    // STB_LOCAL or STB_GLOBAL
    sym_type as i32;   // STT_NOTYPE, STT_SECTION, etc
}

// A parsed relocation from one .o
struct ObjReloc {
    offset as i64;     // r_offset within section
    sym_idx as i32;    // index into ObjFile.syms[] (re-indexed)
    rtype as i64;      // relocation type
    addend as i64;     // r_addend
    section as i32;    // which section this reloc applies to (1=text, 2=data)
}

// Represents one parsed .o file
struct ObjFile {
    filename as *u8;
    data as *u8;       // raw file contents
    file_size as i64;

    // Sections
    text as ObjSection;
    data_sec as ObjSection;
    rodata as ObjSection;
    bss_size as i64;

    // Symbols
    syms as *u8;       // array of ObjSym
    sym_count as i32;

    // Relocations
    relocs as *u8;     // array of ObjReloc
    reloc_count as i32;

    // Offsets assigned during linking (set by linker)
    text_offset as i64;    // offset of this .o's .text in merged text
    data_offset as i64;    // offset of this .o's .data in merged data
    rodata_offset as i64;  // offset of this .o's .rodata in merged rodata
    bss_offset as i64;     // offset of this .o's .bss in merged bss
}

// ============================================================
// ObjSym array helpers
// ============================================================

fn sym_get(obj as *ObjFile, idx as i32) as *ObjSym {
    return cast(*ObjSym, cast(i64, obj.syms) + cast(i64, idx) * sizeof(ObjSym));
}

fn sym_add(obj as *ObjFile, name as *u8, name_len as i32, section as i32,
           value as i64, binding as i32, stype as i32) as void {
    let is *ObjSym as s = cast(*ObjSym, cast(i64, obj.syms) + cast(i64, obj.sym_count) * sizeof(ObjSym));
    s.name = name;
    s.name_len = name_len;
    s.section = section;
    s.value = value;
    s.binding = binding;
    s.sym_type = stype;
    obj.sym_count = obj.sym_count + 1;
}

// ============================================================
// ObjReloc array helpers
// ============================================================

fn reloc_get(obj as *ObjFile, idx as i32) as *ObjReloc {
    return cast(*ObjReloc, cast(i64, obj.relocs) + cast(i64, idx) * sizeof(ObjReloc));
}

fn reloc_add(obj as *ObjFile, offset as i64, sym_idx as i32, rtype as i64,
             addend as i64, section as i32) as void {
    let is *ObjReloc as r = cast(*ObjReloc, cast(i64, obj.relocs) + cast(i64, obj.reloc_count) * sizeof(ObjReloc));
    r.offset = offset;
    r.sym_idx = sym_idx;
    r.rtype = rtype;
    r.addend = addend;
    r.section = section;
    obj.reloc_count = obj.reloc_count + 1;
}

// ============================================================
// I/O helpers
// ============================================================

fn print_str(s as *u8) as void {
    linux.write(linux.STDERR, s, strlen(s));
}

fn print_int(n as i64) as void {
    if (n == 0) { linux.write(linux.STDERR, "0", 1); return; }
    let is [24]u8 as buf;
    let is i64 as val with mut = n;
    let is i64 as neg with mut = 0;
    if (val < 0) { neg = 1; val = 0 - val; }
    let is i32 as pos with mut = 23;
    while (val > 0) {
        buf[pos] = cast(u8, (val % 10) + 48);
        val = val / 10;
        pos = pos - 1;
    }
    if (neg == 1) { buf[pos] = 45; pos = pos - 1; }
    let is i64 as start = cast(i64, pos) + 1;
    linux.write(linux.STDERR, cast(*u8, cast(i64, &buf) + start), 24 - start);
}

fn print_hex(n as i64) as void {
    let is *u8 as hex = "0123456789abcdef";
    let is [18]u8 as buf;
    buf[0] = 48; // '0'
    buf[1] = 120; // 'x'
    let is i64 as i with mut = 0;
    let is i64 as val with mut = n;
    while (i < 16) {
        buf[17 - i] = hex[val & 15];
        val = val >> 4;
        i = i + 1;
    }
    linux.write(linux.STDERR, &buf[0], 18);
}

// ============================================================
// read_obj — parse a single .o file
// ============================================================

fn read_file(path as *u8, out_size as *i64) as *u8 {
    let is i64 as fd = linux.open(path, linux.O_RDONLY, 0);
    if (fd < 0) { return cast(*u8, 0); }
    let is i64 as size = linux.lseek(fd, 0, linux.SEEK_END);
    linux.lseek(fd, 0, linux.SEEK_SET);
    if (size <= 0) { linux.close(fd); return cast(*u8, 0); }
    let is *u8 as buf = mem.galloc(size);
    linux.read(fd, buf, size);
    linux.close(fd);
    *out_size = size;
    return buf;
}

fn read_obj(path as *u8, obj as *ObjFile) as i32 {
    obj.filename = path;
    obj.sym_count = 0;
    obj.reloc_count = 0;
    obj.text_offset = 0;
    obj.data_offset = 0;
    obj.rodata_offset = 0;
    obj.bss_offset = 0;
    obj.bss_size = 0;

    // Read file
    let is i64 as fsize with mut = 0;
    let is *u8 as data = read_file(path, &fsize);
    if (cast(i64, data) == 0) {
        print_str("error: cannot open ");
        print_str(path);
        print_str("\n");
        return 1;
    }
    obj.data = data;
    obj.file_size = fsize;

    // Validate ELF header
    if (fsize < 64) {
        print_str("error: file too small: ");
        print_str(path);
        print_str("\n");
        return 1;
    }

    // Magic: 7f 45 4c 46
    if (data[0] != 127 || data[1] != 69 || data[2] != 76 || data[3] != 70) {
        print_str("error: bad ELF magic: ");
        print_str(path);
        print_str("\n");
        return 1;
    }

    // Class = 2 (64-bit)
    if (data[4] != 2) {
        print_str("error: not 64-bit ELF: ");
        print_str(path);
        print_str("\n");
        return 1;
    }

    // Data = 1 (little-endian)
    if (data[5] != 1) {
        print_str("error: not little-endian: ");
        print_str(path);
        print_str("\n");
        return 1;
    }

    // e_type = ET_REL (offset 16)
    let is i64 as e_type = read_u16(data, 16);
    if (e_type != cast(i64, ET_REL)) {
        print_str("error: not relocatable: ");
        print_str(path);
        print_str("\n");
        return 1;
    }

    // e_machine = EM_X86_64 (offset 18)
    let is i64 as e_machine = read_u16(data, 18);
    if (e_machine != cast(i64, EM_X86_64)) {
        print_str("error: not x86_64: ");
        print_str(path);
        print_str("\n");
        return 1;
    }

    // Section header info
    let is i64 as e_shoff = read_u64(data, 40);      // section header table offset
    let is i64 as e_shentsize = read_u16(data, 58);   // section header entry size
    let is i64 as e_shnum = read_u16(data, 60);       // number of section headers
    let is i64 as e_shstrndx = read_u16(data, 62);    // section name string table index

    if (e_shoff == 0 || e_shnum == 0) {
        print_str("error: no section headers: ");
        print_str(path);
        print_str("\n");
        return 1;
    }

    // Find .shstrtab
    let is i64 as shstrtab_sh = e_shoff + e_shstrndx * e_shentsize;
    let is i64 as shstrtab_off = read_u64(data, shstrtab_sh + 24);
    let is *u8 as shstrtab = cast(*u8, cast(i64, data) + shstrtab_off);

    // Initialize section data to empty
    obj.text.data = cast(*u8, 0);
    obj.text.size = 0;
    obj.data_sec.data = cast(*u8, 0);
    obj.data_sec.size = 0;
    obj.rodata.data = cast(*u8, 0);
    obj.rodata.size = 0;

    // Scan section headers to find sections by name
    let is i64 as symtab_off with mut = 0;
    let is i64 as symtab_size with mut = 0;
    let is i64 as symtab_link with mut = 0;  // strtab section index
    let is i64 as symtab_info with mut = 0;  // first global sym index
    let is i64 as symtab_entsize with mut = 24;

    let is i64 as strtab_off with mut = 0;

    let is i64 as rela_text_off with mut = 0;
    let is i64 as rela_text_size with mut = 0;
    let is i64 as rela_data_off with mut = 0;
    let is i64 as rela_data_size with mut = 0;

    let is i64 as si with mut = 0;
    while (si < e_shnum) {
        let is i64 as sh = e_shoff + si * e_shentsize;
        let is i64 as sh_name_off = read_u32(data, sh);
        let is i64 as sh_type = read_u32(data, sh + 4);
        let is i64 as sh_flags = read_u64(data, sh + 8);
        let is i64 as sh_offset = read_u64(data, sh + 24);
        let is i64 as sh_size = read_u64(data, sh + 32);
        let is i64 as sh_link = read_u32(data, sh + 40);
        let is i64 as sh_info = read_u32(data, sh + 44);

        let is *u8 as name = strtab_get(shstrtab, sh_name_off);

        if (sh_type == cast(i64, SHT_PROGBITS)) {
            if (streq_lit(name, ".text") == 1) {
                obj.text.data = cast(*u8, cast(i64, data) + sh_offset);
                obj.text.size = sh_size;
                obj.text.sh_offset = sh_offset;
            }
            else if (streq_lit(name, ".data") == 1) {
                obj.data_sec.data = cast(*u8, cast(i64, data) + sh_offset);
                obj.data_sec.size = sh_size;
                obj.data_sec.sh_offset = sh_offset;
            }
            else if (streq_lit(name, ".rodata") == 1) {
                obj.rodata.data = cast(*u8, cast(i64, data) + sh_offset);
                obj.rodata.size = sh_size;
                obj.rodata.sh_offset = sh_offset;
            }
        }
        else if (sh_type == cast(i64, SHT_NOBITS)) {
            if (streq_lit(name, ".bss") == 1) {
                obj.bss_size = sh_size;
            }
        }
        else if (sh_type == cast(i64, SHT_SYMTAB)) {
            symtab_off = sh_offset;
            symtab_size = sh_size;
            symtab_link = sh_link;
            symtab_info = sh_info;
            if (read_u64(data, sh + 56) > 0) {
                symtab_entsize = read_u64(data, sh + 56);
            }
        }
        else if (sh_type == cast(i64, SHT_STRTAB) && si != e_shstrndx) {
            strtab_off = sh_offset;
        }
        else if (sh_type == cast(i64, SHT_RELA)) {
            if (streq_lit(name, ".rela.text") == 1) {
                rela_text_off = sh_offset;
                rela_text_size = sh_size;
            }
            else if (streq_lit(name, ".rela.data") == 1) {
                rela_data_off = sh_offset;
                rela_data_size = sh_size;
            }
        }

        si = si + 1;
    }

    // Parse symbol table
    let is *u8 as strtab = cast(*u8, cast(i64, data) + strtab_off);
    let is i64 as num_syms with mut = 0;
    if (symtab_size > 0 && symtab_entsize > 0) {
        num_syms = symtab_size / symtab_entsize;
    }

    // Allocate symbol array (skip null entry at index 0)
    obj.syms = mem.galloc((num_syms + 1) * sizeof(ObjSym));

    let is i64 as syi with mut = 0;
    while (syi < num_syms) {
        let is i64 as ent = symtab_off + syi * symtab_entsize;
        let is i64 as st_name = read_u32(data, ent);
        let is i32 as st_info = cast(i32, read_u8(data, ent + 4));
        let is i64 as st_shndx = read_u16(data, ent + 6);
        let is i64 as st_value = read_u64(data, ent + 8);

        let is i32 as binding = st_info >> 4;
        let is i32 as stype = st_info & 15;

        let is *u8 as sym_name = strtab_get(strtab, st_name);
        let is i32 as sym_name_len = cstrlen(sym_name);
        let is i32 as sec = cast(i32, st_shndx);

        sym_add(obj, sym_name, sym_name_len, sec, st_value, binding, stype);
        syi = syi + 1;
    }

    // Parse .rela.text relocations
    let is i64 as total_relocs = 0;
    if (rela_text_size > 0) { total_relocs = total_relocs + rela_text_size / 24; }
    if (rela_data_size > 0) { total_relocs = total_relocs + rela_data_size / 24; }

    obj.relocs = mem.galloc((total_relocs + 1) * sizeof(ObjReloc));

    if (rela_text_size > 0) {
        let is i64 as num_rela = rela_text_size / 24;
        let is i64 as ri with mut = 0;
        while (ri < num_rela) {
            let is i64 as rent = rela_text_off + ri * 24;
            let is i64 as r_offset = read_u64(data, rent);
            let is i64 as r_info = read_u64(data, rent + 8);
            let is i64 as r_addend = read_u64(data, rent + 16);
            // Sign-extend addend if high bit set (it's a signed i64, but we read as u64)
            // For PC32 relocs, addend is typically -4

            let is i32 as rsym = cast(i32, r_info >> 32);
            let is i64 as rtype = r_info & 4294967295; // 0xFFFFFFFF

            reloc_add(obj, r_offset, rsym, rtype, r_addend, SECIDX_TEXT);
            ri = ri + 1;
        }
    }

    if (rela_data_size > 0) {
        let is i64 as num_rela = rela_data_size / 24;
        let is i64 as ri with mut = 0;
        while (ri < num_rela) {
            let is i64 as rent = rela_data_off + ri * 24;
            let is i64 as r_offset = read_u64(data, rent);
            let is i64 as r_info = read_u64(data, rent + 8);
            let is i64 as r_addend = read_u64(data, rent + 16);

            let is i32 as rsym = cast(i32, r_info >> 32);
            let is i64 as rtype = r_info & 4294967295;

            reloc_add(obj, r_offset, rsym, rtype, r_addend, SECIDX_DATA);
            ri = ri + 1;
        }
    }

    return 0;
}
